#pragma once

#include "ENUMS.h"
#include "TimerManager.h"
#include "PlayerInventory.h"
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GameManager.generated.h"


UCLASS()
class THE_SETTLERS_API AGameManager : public AActor {
	GENERATED_BODY()
public:
	//the static reference to the game manager to make it easier for other classes to access it where necessary
	inline static AGameManager* gameGlobal;
	virtual void BeginPlay() override;
	
	//constructor for the game manager
	AGameManager();

	//Global resources and the deck, static as they need to be accessed from anywhere and they are located only once in the translation units
	inline static TArray<int32> gResources = {10,10,10,10,10};
	inline static TArray<ECards> Gdeck;

	//this function is called to release the locks on the player inventories such as card drawn, card played, etc
	void refreshAll();
	//called by the thief
	void stealAll();	
	PlayerInventory* getPlayer(EPlayer player);
	TArray<ECards> deckMaker(int knight, int vp, int monopoly, int yop, int roads);

	//LOCKS - inline and static so they can be accessed from anywhere and they are located only once in the translation units
	inline static bool monopolyLock = false;
	inline static bool yearOPlentyLock = false;
	inline static bool thiefLock = false;
	inline static bool roadBuildingLock = false;
	inline static int freeRoadsCount = 0;
	inline static EPlayer CurrentPlayer;

	UFUNCTION(BlueprintCallable, Category = "Function")
	EPlayer getCurrentPlayer();

	// Turn duration in seconds
	float TurnDuration = 1000.f;

	//the turn number to be displayed on the HUD
	int32 globalTurn = 1;

	//the array of player inventories that are used to store the players resources and cards
	TArray<PlayerInventory*> invs;

	//Skips the turn of the current player
	UFUNCTION(BlueprintCallable, Category = "Function")
	void SkipTurn();

	//Trade function 
	//Player 1 is the player who the actual player selects
	//player 2 is the player itself
	//returns true if the trade was sucessful false otherwise
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool trade(EPlayer player1, EPlayer player2, EResource resource, EResource resource2);

	//draws the card from the deck in the current players hand
	//returns true if the card was drawn sucessfully false otherwise
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool drawCard();

	//uses the card from the players hand
	//returns true if the card was used sucessfully false otherwise
	//this is called by the HUD
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool useCard(EPlayer player, ECards card);

	//Card functionality functions coupled to the HUD
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool freeRoads(EPlayer player);

	//exeutes the monopoly card behaviour
	//this has no need for validation as this is dont by blueprints so it returns void
	UFUNCTION(BlueprintCallable, Category = "Function")
	void monopoly(EResource resource);

	//does the card behaviour for the knight relative to the player that played it
	//returns true if the card was played sucessfully false otherwise
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool knight(EPlayer player);

	//plays the development card
	//returns true if the card was played sucessfully false otherwise
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool victoryPoint(EPlayer player);

	//needed in the implementation of Year of Plenty
	//returns true if the resource was addes sucessfully false otherwise
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool addResource(EPlayer player, EResource resource);

	//does the maritime trading behaviour
	//returns true if the trade was sucessful false otherwise
	//resource1 is the resource the player is giving 4 of away 
	//resource2 is the resource the player is getting 1 of
	//the resurces are generated by the tradeTiles 
	UFUNCTION(BlueprintCallable, Category = "Function")
	bool shipTrade(EPlayer player, EResource resource1, EResource resource2);
	
	//HUD Value Getters
	UFUNCTION(BlueprintCallable, Category = "Function")
	EPlayer getLargestArmyPlayer();

	UFUNCTION(BlueprintCallable, Category = "Function")
	EPlayer getLongestRoadPlayer();

	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 getPlayerTurn();

	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 getTurnNumber();

	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 getVictoryPoints(EPlayer player);

	UFUNCTION(BlueprintCallable, Category = "Function")
	FString getResourceHUD(EPlayer player, EResource resource);
	
	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 getRemainingTime();

	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 getDice();

	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 getCardCount(EPlayer player, ECards cardC);

	UFUNCTION(BlueprintCallable, Category = "Function")
	int32 knightCount(EPlayer player);
	
private:
	
	int32 dice;
	EPlayer largestArmyPlayer = EPlayer::NONE;
	EPlayer longestRoadPlayer = EPlayer::NONE;
	FTimerHandle TurnTimerHandle;
	
	// start and end turn functions, these never get called by blueprints 
	void StartTurn();
	void EndTurn();

	//called by the timer to end the turn
	void largestArmy();
	void longestRoad();
	//the year of plenty card behaviour of the bots
	void yearOPlenty();
};